# Genearlly when testing rvos I rely on code generated by a compiler (Gnu or BA) since that way I'm
# sure the instructions decode and behave correctly. This file is to validate instructions I
# couldn't convince those compilers to emit. This is obviously worse, because while I can
# validate decoding, I can't validate behavior because I might be confused about what the
# correct behavior is. But it's better than nothing.


.section        .sbss,"aw",@nobits
  .align 3
  print_buffer:
    .zero 256

  .align 3
  eightBytes:
   .zero 8

  .align 3
  fourBytes:
   .zero 4

  .align 3
  sixteenBytes:
   .zero 16

.section .rodata
  newlineString:
   .string "\n"

  errorString:
   .string " error\n"

  helloString:
   .string "hello\n"

  endString:
   .string "test instructions is complete\n"

.text
.align 3

.ifdef OLDGCC
.globl _start
.type _start, @function
_start:
    .cfi_startproc

    # arguments are up the stack just like Linux

    ld       a0, 0(sp)
    addi     a1, sp, 8

    jal      main

    li       a7, 93 # linux exit system call for risc-v
    ecall
    .cfi_endproc
.endif

.globl main
.type main, @function
main:
    .cfi_startproc
    addi     sp, sp, -128
    sd       ra, 16(sp)
    sd       s0, 24(sp)
    sd       s1, 32(sp)
    sd       s2, 40(sp)
    sd       s3, 48(sp)
    sd       s4, 56(sp)
    sd       s5, 64(sp)
    sd       s6, 72(sp)
    sd       s7, 80(sp)
    sd       s8, 88(sp)
    sd       s9, 96(sp)
    sd       s10, 104(sp)
    sd       s11, 112(sp)

    lla      a0, helloString
    jal      rvos_print_text

    ebreak

  test_amoswap.w:
    li       a0, 3
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xc
    amoswap.w.rl a3, a1, (t0)
    bne      a0, a3, test_fail_1
    lw       a4, (t0)
    bne      a1, a4, test_fail_2

  test_amoadd.w:
    li       a0, 3
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xc
    amoadd.w a3, a1, (t0)
    bne      a0, a3, test_fail_3
    lw       a4, (t0)
    li       a1, 0xf
    bne      a1, a4, test_fail_4

  test_amoxor.w:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amoxor.w a3, a1, (t0)
    bne      a0, a3, test_fail_5
    lw       a4, (t0)
    li       a1, 0x9
    bne      a1, a4, test_fail_6

  test_amoand.w:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amoand.w a3, a1, (t0)
    bne      a0, a3, test_fail_7
    lw       a4, (t0)
    li       a1, 0x6
    bne      a1, a4, test_fail_8

  test_amoor.w:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amoor.w  a3, a1, (t0)
    bne      a0, a3, test_fail_9
    lw       a4, (t0)
    li       a1, 0xf
    bne      a1, a4, test_fail_10

  test_amomax.w:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amomax.w a3, a1, (t0)
    bne      a0, a3, test_fail_11
    lw       a4, (t0)
    li       a1, 0xe
    bne      a1, a4, test_fail_12

  test_amomin.w:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amomin.w a3, a1, (t0)
    bne      a0, a3, test_fail_13
    lw       a4, (t0)
    li       a1, 0x7
    bne      a1, a4, test_fail_14

  test_amoswap.d:
    li       a0, 3
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xc
    amoswap.d.rl a3, a1, (t0)
    bne      a0, a3, test_fail_15
    lw       a4, (t0)
    bne      a1, a4, test_fail_16

  test_amoadd.d:
    li       a0, 3
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xc
    amoadd.d a3, a1, (t0)
    bne      a0, a3, test_fail_17
    lw       a4, (t0)
    li       a1, 0xf
    bne      a1, a4, test_fail_18

  test_amoxor.d:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amoxor.d a3, a1, (t0)
    bne      a0, a3, test_fail_19
    lw       a4, (t0)
    li       a1, 0x9
    bne      a1, a4, test_fail_20

  test_amoand.d:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amoand.d a3, a1, (t0)
    bne      a0, a3, test_fail_21
    lw       a4, (t0)
    li       a1, 0x6
    bne      a1, a4, test_fail_22

  test_amoor.d:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amoor.d  a3, a1, (t0)
    bne      a0, a3, test_fail_23
    lw       a4, (t0)
    li       a1, 0xf
    bne      a1, a4, test_fail_24

  test_amomax.d:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amomax.d a3, a1, (t0)
    bne      a0, a3, test_fail_25
    lw       a4, (t0)
    li       a1, 0xe
    bne      a1, a4, test_fail_26

  test_amomin.d:
    li       a0, 7
    lla      t0, fourBytes
    sw       a0, (t0)
    li       a1, 0xe
    amomin.d a3, a1, (t0)
    bne      a0, a3, test_fail_27
    lw       a4, (t0)
    li       a1, 0x7
    bne      a1, a4, test_fail_28
    j        clean_exit

  test_fail_1:
    li       a0, 1
    j        show_error
  test_fail_2:
    li       a0, 2
    j        show_error
  test_fail_3:
    li       a0, 3
    j        show_error
  test_fail_4:
    li       a0, 4
    j        show_error
  test_fail_5:
    li       a0, 5
    j        show_error
  test_fail_6:
    li       a0, 6
    j        show_error
  test_fail_7:
    li       a0, 7
    j        show_error
  test_fail_8:
    li       a0, 8
    j        show_error
  test_fail_9:
    li       a0, 9
    j        show_error
  test_fail_10:
    li       a0, 10
    j        show_error
  test_fail_11:
    li       a0, 11
    j        show_error
  test_fail_12:
    li       a0, 12
    j        show_error
  test_fail_13:
    li       a0, 13
    j        show_error
  test_fail_14:
    li       a0, 14
    j        show_error
  test_fail_15:
    li       a0, 15
    j        show_error
  test_fail_16:
    li       a0, 16
    j        show_error
  test_fail_17:
    li       a0, 17
    j        show_error
  test_fail_18:
    li       a0, 18
    j        show_error
  test_fail_19:
    li       a0, 19
    j        show_error
  test_fail_20:
    li       a0, 20
    j        show_error
  test_fail_21:
    li       a0, 21
    j        show_error
  test_fail_22:
    li       a0, 22
    j        show_error
  test_fail_23:
    li       a0, 23
    j        show_error
  test_fail_24:
    li       a0, 24
    j        show_error
  test_fail_25:
    li       a0, 25
    j        show_error
  test_fail_26:
    li       a0, 26
    j        show_error
  test_fail_27:
    li       a0, 27
    j        show_error
  test_fail_28:
    li       a0, 28
    j        show_error

  show_error:
    jal      print_int
    lla      a0, errorString
    jal      rvos_print_text
    li       a0, -1
    j        leave_execution

  clean_exit:
    add      a0, zero, zero
    lla      a0, endString
    jal      rvos_print_text

  leave_execution:
    ld       ra, 16(sp)
    ld       s0, 24(sp)
    ld       s1, 32(sp)
    ld       s2, 40(sp)
    ld       s3, 48(sp)
    ld       s4, 56(sp)
    ld       s5, 64(sp)
    ld       s6, 72(sp)
    ld       s7, 80(sp)
    ld       s8, 88(sp)
    ld       s9, 96(sp)
    ld       s10, 104(sp)
    ld       s11, 112(sp)
    addi     sp, sp, 128

    jr       ra
    .cfi_endproc

# Use this rvos system call instead of the C Runtime or a Linux system call so this app
# can run on actual Risc-V hardware that might not have either of those, like the SiPeed
# Kentryte K210 system. There text output goes to an LCD using a bespoke API.

.globl rvos_print_text
.type rvos_print_text, @function
rvos_print_text:
        .cfi_startproc
        addi    sp, sp, -32
        sd      ra, 16(sp)

        li      a7, 0x2004 # rvos_sys_print_text
        ecall

        ld      ra, 16(sp)
        addi    sp, sp, 32
        jr      ra
        .cfi_endproc

print_int:
    .cfi_startproc
    addi     sp, sp, -32
    sd       ra, 16(sp)
    lla      a1, print_buffer
    li       a2, 10
    jal      _my_lltoa
    lla      a0, print_buffer
    jal      rvos_print_text
    ld       ra, 16(sp)
    addi     sp, sp, 32
    jr       ra
    .cfi_endproc

_my_lltoa:
    .cfi_startproc
    li       t1, 9
    bne      a0, zero, .my_lltoa_not_zero
    li       t0, '0'
    sb       t0, 0(a1)
    sb       zero, 1(a1)
    j        .my_lltoa_exit
  .my_lltoa_not_zero:
    li       t2, 0           # offset into the string
    mv       t6, zero        # default to unsigned
    li       t0, 10          # negative numbers only exist for base 10
    bne      a2, t0, .my_lltoa_digit_loop
    li       t0, 0x8000000000000000
    and      t0, a0, t0
    beq      t0, zero, .my_lltoa_digit_loop
    li       t6, 1           # it's negative
    neg      a0, a0          # this is just sub a0, zero, a0
  .my_lltoa_digit_loop:
    beq      a0, zero, .my_lltoa_digits_done
    rem      t0, a0, a2
    bgt      t0, t1, .my_lltoa_more_than_nine
    addi     t0, t0, '0'
    j       .my_lltoa_after_base
  .my_lltoa_more_than_nine:
    addi     t0, t0, 'a' - 10
  .my_lltoa_after_base:
    add      t3, a1, t2
    sb       t0, 0(t3)
    addi     t2, t2, 1
    div      a0, a0, a2
    j        .my_lltoa_digit_loop
  .my_lltoa_digits_done:
    beq      t6, zero, .my_lltoa_no_minus
    li       t0, '-'
    add      t3, a1, t2
    sb       t0, 0(t3)
    addi     t2, t2, 1
  .my_lltoa_no_minus:
    add      t3, a1, t2      # null-terminate the string
    sb       zero, 0(t3)
    mv       t4, a1          # reverse the string. t4 = left
    add      t5, a1, t2      # t5 = right
    addi     t5, t5, -1
  .my_lltoa_reverse_next:
    bge      t4, t5, .my_lltoa_exit
    lbu      t0, (t4)
    lbu      t1, (t5)
    sb       t0, (t5)
    sb       t1, (t4)
    addi     t4, t4, 1
    addi     t5, t5, -1
    j       .my_lltoa_reverse_next
  .my_lltoa_exit:
    jr       ra
    .cfi_endproc

